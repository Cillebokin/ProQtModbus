# 一、Modbus简介 
 Modbus通信协议是由Modicon公司于1979年为可编程逻辑控制通信而发表。目前，Modbus已经成为工业领域通信协议的业界标准，并且现在是工业电子设备之间常用的连接方式。Modbus作为工业领域应用最广泛的协议，于其他通信协议相比，有以下特点：

* Modbus协议标准开放、公开发表且无版权要求。
* Modbus协议支持多种电气接口，包括RS232、RS485、TCP/IP等，还可以在各种介质上传输，如双绞线、光纤、红外、无线等。
* Modbus协议消息帧格式简单、紧凑、通俗易懂。
* Modbus协议用户理解和使用简单，厂商容易开发和集成，方便形成工业控制网络。

Modbus是 OSI 模型第 7 层上的应用层报文传输协议，它在连接至不同类型总线或网络的设备 之间提供客户机/服务器通信。自从 1979 年出现工业串行链路的事实标准以来，Modbus 使成千上万的自动化设备能够通信。

目前，继续增加对简单而雅观的 MODBUS 结构支持。互联网组织能够使 TCP/IP 栈上的保留系统端 口 502 访问 Modbus。 

Modbus是一个请求/应答协议，并且提供功能码规定的服务。Modbus功能码是Modbus请求/应答 PDU 的元素。本文件的作用是描述 MODBUS 事务处理框架内使用的功能码。

![image-20210616125543889](.\20210617124801.png)

# 二、Modbus常见协议类型

Modbus协议是一种应用层报文传输协议，包括ASCII、RTU、TCP三种报文类型。

协议使用串口传输时可选择RTU或ASCII模式，并规定了消息、数据结构、命令和应答方式并需要对数据进行校验。ASCII模式采用LRC校验，RTU采用16位CRC校验，通过以太网传输时使用TCP，由于TCP协议是一个面向连接的可靠协议因此不适用校验。

常见的协议类型包括：

* ModbusRtu
* ModbusAscii
* ModbudTcp
* ModbusUdp
* ModbusRtuOverTcp
* ModbusRtuOverUdp
* ModbusAsciiOverTcp
* ModbusAsciiOverUdp

# 三、Modbus存储区

Modbus以一系列具有不同特征表格上的数据模型为基础，在不同的存储区数据有不同的表示类型：布尔量、寄存器。

而对存储区的操作读写性有：只读、读写。

对其进行组合就会形成不同的存储区，如下表所示：

| 区号 |    名称    | 读写性 |    范围     |
| :--: | :--------: | :----: | :---------: |
|  0   |  输出线圈  | 可读写 | 00001-09999 |
|  1   |  输入线圈  |  只读  | 10001-19999 |
|  3   | 输入寄存器 |  只读  | 30001-39999 |
|  4   | 输出寄存器 | 可读写 | 40001-49999 |

输入与输出之间以及比特寻址的和字寻址的数据项之间的区别并没有暗示任何应用操作。如果 这是对可疑对象核心部分最自然的解释，那么这种区别是可完全接受的，而且很普通，以便认为表格全部覆盖了另外一个表格。

# 四、Modbus功能码

对存储区的数据进行读写称作功能，不同的功能用不同的功能码区分，常见的有八种：

| 功能码 |      功能说明      |
| :----: | :----------------: |
|  0x01  |    读取输出线圈    |
|  0x02  |    读取输入线圈    |
|  0x03  |   读取输出寄存器   |
|  0x04  |   读取输入寄存器   |
|  0x05  |  写入单个输出线圈  |
|  0x06  | 写入单个输出寄存器 |
|  0x0F  |  写入多个输出线圈  |
|  0x10  | 写入多个输出寄存器 |

# 五、Modbus报文格式

Modbus协议定义了一个与基础通信层无关的简单协议数据单元（PDU）。特定总线或网络上 的Modbus协议映射能够在应用数据单元（ADU）上引入一些附加域。 

针对Modbus具体报文进行分析，Modbus协议在串行链路上的报文格式如下所示：

| 从站地址 | 功能码 |  数据  | 差错校验 |
| :------: | :----: | :----: | :------: |
|  1 byte  | 1 byte | N byte |  2 byte  |

![image-20210616125543889](.\20210617124707.png)

## 1. 读取多线圈

发送报文格式如下：

| 从站地址 | 功能码 | 起始地址(高) | 起始地址(低) | 数量(高) | 数量(低) |  校验  |
| :------: | :----: | :----------: | :----------: | :------: | :------: | :----: |
|   0x01   |  0x01  |     0x00     |     0x13     |   0x00   |   0x1B   |  XXXX  |
|  1 byte  | 1 byte |    1 byte    |    1 byte    |  1 byte  |  1 byte  | 2 byte |

报文含义：

读取1号从站的输出线圈，起始地址为0x0013 = 19，对应地址为00020，线圈数量为0x001B = 27，即读取1号从站输出线圈，地址从00020 - 00046，共27个线圈的状态值。

返回报文格式如下：

| 从站地址 | 功能码 | 字节数 | 字节1  | 字节2  | 字节3  | 字节4  | 字节... |  校验  |
| :------: | :----: | :----: | :----: | :----: | :----: | :----: | :-----: | :----: |
|   0x01   |  0x01  |  0x04  |  0xCD  |  0x6B  |  0xB2  |  0x05  |  0x...  |  XXXX  |
|  1 byte  | 1 byte | 1 byte | 1 byte | 1 byte | 1 byte | 1 byte | 1 byte  | 2 byte |

返回报文含义：

返回1号从站输出线圈00020 - 00046，共27个线圈的状态值，返回字节数为4个，分别为CD 6B B2 05。

CD = 1100 1101 对应 00020 - 00027

6B = 0110 1011 对应 00028 - 00035

B2 = 1011 0010 对应 00036 - 00043

05 = 0000 0101 对应 00044 - 00046

## 2.读取多寄存器

发送报文格式如下：

| 从站地址 | 功能码 | 起始地址(高) | 起始地址(低) | 数量(高) | 数量(低) |  校验  |
| :------: | :----: | :----------: | :----------: | :------: | :------: | :----: |
|   0x01   |  0x03  |     0x00     |     0x6B     |   0x00   |   0x02   |  XXXX  |
|  1 byte  | 1 byte |    1 byte    |    1 byte    |  1 byte  |  1 byte  | 2 byte |

发送报文含义：

读取1号从站的输出寄存器，起始地址为0x006B = 107，对应地址为40108（40001 + 107），寄存器数量为0x0002 = 2，即读取1号从站输出寄存器，地址从40108 - 40109，共两个寄存器的值。

返回报文格式如下：

| 从站地址 | 功能码 | 字节数 | 寄存器1(高) | 寄存器1(低) | 寄存器2(高) | 寄存器2(低) |  校验  |
| :------: | :----: | :----: | :---------: | :---------: | :---------: | :---------: | :----: |
|   0x01   |  0x03  |  0x04  |    0x02     |    0x2B     |    0x01     |    0x06     |  XXXX  |
|  1 byte  | 1 byte | 1 byte |   1 byte    |   1 byte    |   1 byte    |   1 byte    | 2 byte |

返回报文含义：

返回1号从站输出寄存器40108 - 40109，共两个寄存器的值，返回字节数为4个，分别为02 2B 01 06。

40108寄存器对应数值为0x022B

40108寄存器对应数值为0x0106

## 3.写入多线圈

发送报文格式如下：

| 从站地址 | 功能码 | 起始地址(高) | 起始地址(低) | 数量(高) | 数量(低) | 字节数 | 设定值1 | 设定值2 | 校验   |
| :------: | :----: | :----------: | :----------: | :------: | :------: | :----: | :-----: | :-----: | ------ |
|   0x01   |  0x0F  |     0x00     |     0x13     |   0x00   |   0x0A   |  0x02  |  0xCD   |  0X00   | XXXX   |
|  1 byte  | 1 byte |    1 byte    |    1 byte    |  1 byte  |  1 byte  | 1 byte | 1 byte  | 1 byte  | 2 byte |

发送报文含义：

写入1号从站多个线圈的值，线圈地址为0x0013 = 19，对应地址为00020，线圈数为0x000A = 10，写入值为0xCD00，即写入1号从站线圈00020 - 00027对应0xCD = 1100 1101，00028 - 00029对应0x00 = 00。

返回报文格式如下：

| 从站地址 | 功能码 | 起始地址(高) | 起始地址(低) | 数量(高) | 数量(低) |  校验  |
| :------: | :----: | :----------: | :----------: | :------: | :------: | :----: |
|   0x01   |  0x0F  |     0x00     |     0x13     |   0x00   |   0x0A   |  XXXX  |
|  1 byte  | 1 byte |    1 byte    |    1 byte    |  1 byte  |  1 byte  | 2 byte |

返回报文含义：

写入多线圈返回报文是在原报文的基础上去除字节数及具体字节后返回。

## 4.写入多寄存器

发送报文格式如下：

| 从站地址 | 功能码 | 起始地址(高) | 起始地址(低) | 数量(高) | 数量(低) | 字节数 |    字节    |  校验  |
| :------: | :----: | :----------: | :----------: | :------: | :------: | :----: | :--------: | :----: |
|   0x01   |  0x10  |     0x00     |     0x87     |   0x00   |   0x02   |  0x04  | 0x01050A10 |  XXXX  |
|  1 byte  | 1 byte |    1 byte    |    1 byte    |  1 byte  |  1 byte  | 1 byte |   N byte   | 2 byte |

发送报文含义：

写入1号从站多个寄存器的值，寄存器的地址为0x0087 = 135，起始地址为40136（40001 + 135），寄存器数量为0x0002 = 2，则结束地址为40137，写入值为0x0105和0x0A10，即写入1号从站寄存器40136为0x0105，而40137为0x0A10。

返回报文格式如下：

| 从站地址 | 功能码 | 起始地址(高) | 起始地址(低) | 数量(高) | 数量(低) | 校验 |
| :------: | :----: | :----------: | :----------: | :------: | :------: | :--: |
|   0x01   |  0x10  |     0x00     |     0x87     |   0x00   |   0x02   | XXXX |

返回报文含义：

写入多寄存器返回报文是在原报文的基础上去除字节数及具体的字节后返回。

# 六、Modbus异常响应

当客户机设备向服务器设备发送请求时，客户机希望一个正常的响应，从主站询问中出现下列四种可能事件之一：

* 如果服务器设备接收到无通信错误的请求，并且可以正常地处理询问，那么服务器设备将返回一个正常响应。
* 如果由于通信错误，服务器没有接收到请求，那么不能返回响应，客户机程序将最终处理请求地超时状态。
* 如果服务器接收到请求，但是检测到一个通信错误（如CRC校验等），那么不能返回响应，客户机程序最终处理请求的超时状态。
* 如果服务器接收到无通信错误的请求，但不能处理这个请求（例如请求读一个不存在的输出或寄存器），服务器将返回一个异常响应，通知用户错误的本质特性。

![image-20210616125543889](.\20210617124357.png)

异常响应报文有两个与正常响应不同的域：

<b>功能码域</b>：在正常响应中，服务器利用响应功能码来应答最初请求的功能码。所有功能码的最高有效位（MSB）都为0（它们的值都低于十六进制的0x80），这使得响应中的功能码值比正常响应中的功能码的值高十六进制的0x80。

通过设置功能码的MSB，客户机的应用程序能够识别异常响应，并且能够检测异常码的数据域。

`异常功能码 = 正常响应功能码 + 0x80`

<b>数据域</b>：在正常响应中，服务器可以返回数据域中的数据或统计表，而在异常响应中，服务器返回异常码，定义了服务器的异常响应状态。

<b>异常码表</b>：

| 代码 |         名称         | 含义                                                         |
| :--: | :------------------: | :----------------------------------------------------------- |
| 0x01 |       非法功能       | 对于服务器（或从站）来说，询问中接收到的功能码是不可允许的操作，可能是因为功能码仅适用于新设备而被选单元中不可实现同时，还指出服务器（或从站）在错误状态中处理这种请求，例如：它是未配置的，且要求返回寄存器值。 |
| 0x02 |     非法数据地址     | 对于服务器（或从站）来说，询问中接收的数据地址是不可允许的地址，特别是参考号和传输长度的组合是无效的。对于带有100个寄存器的控制器来说，偏移量96和长度4的请求会成功，而偏移量96和长度5的请求将产生异常码02。 |
| 0x03 |      非法数据值      | 对于服务器（或从站）来说，询问中包括的值是不可允许的值。该值指示了组合请求剩余结构中的故障。例如：隐含长度是不正确的。modbus协议不知道任何特殊寄存器的任何特殊值的重要意义，寄存器中被提交存储的数据项有一个应用程序期望之外的值。 |
| 0x04 |     从站设备故障     | 当服务器（或从站）正在设法执行请求的操作时，产生不可重新获得的差错。 |
| 0x05 |         确认         | 与编程命令一起使用，服务器（或从站）已经接受请求，并且正在处理这个请求，但是需要长持续时间进行这些操作，返回这个响应防止在客户机（或主站）中发生超时错误，客户机（或主机）可以继续发送轮询程序完成报文来确认是否完成处理。 |
| 0x06 |      丛属设备忙      | 与编程命令一起使用，服务器（或从站）正在处理长持续时间的程序命令，当服务器（或从站）空闲时，客户机（或主站）应该稍后重新传输报文。 |
| 0x08 |    存储奇偶性差错    | 与功能码20和21以及参考类型6一起使用，指示扩展文件区不能通过一致性校验。服务器（或从站）设备读取记录文件，但在存储器中发现一个奇偶校验错误。客户机（或主机）可重新发送请求，但可以在服务器（或从站）设备上要求服务。 |
| 0x0A |    不可用网关路径    | 与网关一起使用，指示网关不能为处理请求分配输入端口值输出端口的内部通信路径，通常意味着网关是错误配置的或过载的。 |
| 0x0B | 网关目标设备响应失败 | 与网关一起使用，指示没有从目标设备中获得响应，通常意味着设备未在网络中。 |

![image-20210616125543889](.\20210617125212.png)

# 七、串行传输模式

串行模式被定义为RTU模式和ASCII模式。它定义了报文域的位内容在线路上串行的传送，确定了信息如何打包为报文和解码。Modbus串行链路上的所有设备的传输模式（和串行口参数）必须相同，尽管在特定的领域ASCII模式时要求的，但大道Mosbus设备之间的互操作性只有每个设备都有相同的模式：所有设备必须实现RTU模式。ASCII传输模式时选项。

## 1.RTU传输模式

当设备使用RTU模式在Modbus串行链路通信，报文中每个8位字节含有两个4位十六进制字符。这种模式的主要优点时较高的数据密度，在相同的波特率下比ASCII模式有更高的吞吐率。每个报文必须以连续的字符流传送。

Modbus报文RTU帧由发送设备将Modbus报文构造为带有已知起始和结束标记的帧。这使设备可以在报文的开始接收新帧，并且指导何时报文结束。不完整的报文必须能够被检测到而错误标志必须作为结果被设置。在RTU模式，报文帧由时长至少为3.5个字符时间的空闲间隔区分。在后续的部分，这个时间区间被称作t3.5。

![image-20210616125543889](.\image-20210616125543889.png)

整个报文帧必须以连续的字符流发送。如果两个字符之间的空闲间隔大于1.5个字符时间，则报文帧被认为不完整应该被接收节点丢弃。

## 2.ASCII传输模式

当Modbus串行链路的设备被配置为使用ASCII模式通信时，报文中的每个8为子节以两个ASCII字符发送，当通信链路或设备无法符合RTU模式的定时管理时使用该模式。

Modbus ASCII报文帧由发送设备将Modbus报文构造成带有已知起始和结束标记的帧。这使设备可以在报文的开始接收新帧，并且指导何时报文结束，不完整的报文必须能够被检测到而错误标志必须作为结果被记录。报文帧的地址域含有两个字符。

在ASCII模式，报文用特殊的字符区分帧起始和帧结束，一个报文必须以一个冒号（: 即ASCII十六进制0x3A）起始，以回车（ASCII十六进制0x0D和0x0A）结束。对于所有的域，允许传送的字符为十六进制0-9，A-F，设备连续的监视总线上的“冒号”字符，当收到这个字符后，每个设备解码后续的字符一直到帧结束。

![image-20210616131330990](.\image-20210616131330990.png)

# 八、TCP传输模式

在TCP/IP上使用一种专用报文头识别Modbus应用数据单元，将这种报文头称为MBAP报文头。MBAP报文头包括下列域，长度为7字节：

| 事务处理标识 | 协议标识 |  长度  | 单元标识符 |
| :----------: | :------: | :----: | :--------: |
|    2 byte    |  2 byte  | 2 byte |   1 byte   |

* 事务处理标识：可以理解为报文的序列号，一般每次通信之后就要加1以区别不同的通信数据报文。
* 协议标识符：00 00表示ModbusTCP协议。
* 长度，表示接下来的数据长度，单位为字节。
* 单元标识符：可以理解为设备地址。

![image-20210616134931216](.\image-20210616134931216.png)

# 九、一帧报文的最大长度

关于ModbusRTU和ModbusTCP一帧的报文长度，早期在RS485串行通信中规定ADU的最大长度为256个字节，其中：通信地址占一个字节，校验段占两个字节，所以协议数据单元（PDU）的最大长度为256-1-2 = 253个字节。

而ModbusTCP因为要增加一个7个字节的MBAP的报文头，所以其ADU长度为253+7 = 260字节。

* ModbusRTU

  ADU （256byte）:

  从站地址（1byte） 功能码（1byte） 数据（0-252byte） CRC（2byte）

* ModbusTCP

  ADU （260byte）：

  事务元标识符（2byte） 协议标识符（2byte）长度（2byte） 从站地址（1byte）功能码（1byte）数据（0-252byte）

# 十、CRC校验

在RTU模式包含一个对全部报文内容执行的，基于CRC(循环冗余校验)算法的错误检验域，CRC域检验整个报文的内容，不管报文有无奇偶校验均执行此步骤。CRC域包含由两个字节组成的一个16位值，作为报文最后的域附加在报文之后，计算后，首先附加低字节，然后是高字节，CRC高字节作为报文发送的最后一个子节。

附加在报文后面的CRC值由发送设备计算，接收设备在接收报文后重新计算CRC的值，并将计算结果与实际接收到的CRC的值做比较，如果两值不相等，则为错误。

CRC的计算，开始对一个16位寄存器预装全1，然后将报文中的连续的8位子节对其进行后续的计算。只有字符中的8个数据位参与生成CRC的运算，起始位，停止位和校验位不参与CRC的计算。

CRC的生成过程中，每个8位字符与寄存器的中的值异或。然后结果向最低有效位方向移动1位，而最高有效位位置充零。然后提取并检查最低有效位，如果其为1，则寄存器中的值与一个固定的预置值异或；如果其为0则不进行异或操作。

这个过程将重复直到执行完8次位移。完成最后一次位移及相关操作后，下一个8位子节与寄存器的当前值异或，然后又同上面描述过的一样重复八次，当所有报文中子节都运算之后得到的寄存器中的最终值，就是CRC值。

当CRC附加在报文之后时，首先附加低字节，然后是高字节。CRC的具体计算方法如下：

* 多项式（Polynomical）：使用多项式运算是为了在进行二进制计算时无需考虑进位问题。

例如，CRC校验中，多项式可表达为：

`1 * x^6 + 0 * x^5 + 1 * x^4 + 0 * x^3 + 1 * x^2 + 1 * x^1 + 1 * x^0`

可简写为：

`x^6 + x^4 + x^2 + x + 1`

CRC中使用到的除数，正是多项式的各项系数组成，即：

`1010111`

* 在原数据的末端添加0，0的数量由多项式决定，如：

原数据：`1101011011`，多项式：`1010111`（六次项）

则原数据变为：`1101011011000000`

* 进行循环异或运算（XOR）：相同为0，不同为1

`1101011011000000`

`1010111`						异或得：

`0111100`

将后续数据接在其后作为新的数据，并去除前导0，再与除数异或：

`0111100011000000`

`1010111`						异或得：

`0101111`

重复前面步骤进行循环，直到所有数据都处理过为止。所得到得结果即为CRC校验和，将校验和加在数据项之后，便是带有CRC校验得数据，有一处需要注意的地方，当最后结果有效位数较少时，最后拼接校验和的时候，不能漏掉前面的0。



